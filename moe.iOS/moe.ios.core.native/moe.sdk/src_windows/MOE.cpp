/*
 * Copyright (c) 2014-2016, Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <Windows.h>
#include <Pathcch.h>
#include <Shlobj.h>

#include <modern.h>

#undef NDEBUG
#include <assert.h>

#include <string>
#include <vector>
#include <fstream>

//#include "base/logging.h"

#define CLASSPATH_PREFIX "-cp"

#define BOOTCLASSPATH_PREFIX L"-Xbootclasspath:"
#define BOOTCLASSPATH_CORE L"moe-ios-dex.jar"
#define BOOTCLASSPATH_MAIN L"classes.jar"
#define RESOURCES_NAME L"application.jar"

#define xstr(s) str(s)
#define str(s) #s

// Defined in dalvikvm
extern "C" int dalvikvm(int argc, char** argv, int prec, char* const prev[]);

// MOE TODO: This is needed to forcibly include required symbols for code generated by LLVM.
extern "C" void artDeliverPendingExceptionFromCode(void*);
extern "C" void* artFindNativeMethod(void*);
extern void MOEDummyReferenceForLLVM() {
    artDeliverPendingExceptionFromCode(nullptr);
    artFindNativeMethod(nullptr);
}

// MOE TODO: This is needed to forcibly include required symbols for LibCore.
extern "C" int __stdcall JNI_OnLoad_javacore(void*, void*);
extern "C" int __stdcall JNI_OnLoad_openjdk(void*, void*);
extern void MOEDummyReferenceForLibCore() {
    JNI_OnLoad_javacore(nullptr, nullptr);
    JNI_OnLoad_openjdk(nullptr, nullptr);
}

#ifdef MOE
__declspec(dllexport)
#endif
int moevm(const int jargc, char* const* jargv) {
    // Get executable path
    HMODULE hModule = GetModuleHandleW(NULL);
    WCHAR execPath[MAX_PATH];
    GetModuleFileNameW(hModule, execPath, MAX_PATH);
    PathCchRemoveFileSpec(execPath, MAX_PATH);
    
    // Set ICU properties
#ifndef USE_APLE_CF
    _wputenv((std::wstring(L"MOE_ICU_DATA=") + execPath).c_str());
#endif

    // Set default properties
    WCHAR tempPath[MAX_PATH];
    GetTempPathW(MAX_PATH, tempPath);
    _wputenv((std::wstring(L"MOE_TMP_DIR=") + tempPath).c_str());

    WCHAR homePath[MAX_PATH];
    SHGetFolderPathW(NULL, CSIDL_PROFILE, NULL, 0, homePath);
    _wputenv((std::wstring(L"MOE_USER_HOME=") + homePath).c_str());
    
    _wputenv(L"MOE_USER_NAME=moeuser");
    _wputenv(L"MOE_USER_SHELL=C:\\Windows\\System32\\cmd.exe");
    
    WCHAR androidRootPath[MAX_PATH];
    wcsncpy_s(androidRootPath, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(androidRootPath, MAX_PATH, L"android_root");
    _wputenv((std::wstring(L"ANDROID_ROOT=") + androidRootPath).c_str());
    
    WCHAR androiDataPath[MAX_PATH];
    wcsncpy_s(androiDataPath, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(androiDataPath, MAX_PATH, L"android_data");
    _wputenv((std::wstring(L"ANDROID_DATA=") + androiDataPath).c_str());

    // Create array for arguments
    std::vector<std::string> args;

    // Add ignorable first arg
    args.push_back("");

    // Set MOE specific properties
    DWORD ver = GetVersion();
    DWORD verMajor = (DWORD)(LOBYTE(LOWORD(ver)));
    DWORD verMinor = (DWORD)(HIBYTE(LOWORD(ver)));
    std::string verStr = std::string("-Dmoe.platform.version=") + (CHAR)verMajor + '.' + (CHAR)verMinor;
    args.push_back(verStr);
    args.push_back("-Dmoe.platform.name=Windows");
    args.push_back("-Dmoe.version=" xstr(BUILD_VERSION));

    // Create arguments for classpath
    args.push_back(CLASSPATH_PREFIX);
    WCHAR resourcePath[MAX_PATH];
    wcsncpy_s(resourcePath, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(resourcePath, MAX_PATH, RESOURCES_NAME);
    std::wstring resourcesStr = std::wstring(resourcePath) + L';' + execPath;
    // TODO: We have to add unicode argument support to ART, if it is not yet present
    // and then remove this conversion below.
    std::string resourcesStrA(resourcesStr.begin(), resourcesStr.end());
    args.push_back(resourcesStrA);

    // Create argument for boot classpath, resources will be placed there
    WCHAR bootClasspathCore[MAX_PATH];
    wcsncpy_s(bootClasspathCore, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(bootClasspathCore, MAX_PATH, BOOTCLASSPATH_CORE);
    WCHAR bootClasspathMain[MAX_PATH];
    wcsncpy_s(bootClasspathMain, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(bootClasspathMain, MAX_PATH, BOOTCLASSPATH_MAIN);
    std::wstring bootClasspathStr = std::wstring(BOOTCLASSPATH_PREFIX) + bootClasspathCore + L';' + bootClasspathMain;
    // TODO: We have to add unicode argument support to ART, if it is not yet present
    // and then remove this conversion below.
    std::string bootClasspathStrA(bootClasspathStr.begin(), bootClasspathStr.end());
    args.push_back(bootClasspathStrA);

    // Read VM args
    int jargi = 1;
    std::string mainClass;
    while (jargi < jargc) {
        std::string opt = jargv[jargi++];
        if (opt == "-mainClass") {
            if (jargi < jargc) {
                mainClass = jargv[jargi++];
            } else {
                assert(!"Missing argument after -mainClass");
            }
        } else if (opt == "-args") {
            break;
        } else {
            args.push_back(opt);
        }
    }

    // Create argument for main class
    if (mainClass.empty()) {
        try {
            Modern::Initialize();
            Modern::Windows::UI::Xaml::ResourceDictionary resources = Modern::Windows::UI::Xaml::Application::Current().Resources();
            for (auto iter = resources.First(); iter.HasCurrent(); iter.MoveNext())
            {
                auto entry = iter.Current();
                auto key = entry.Key().As<Modern::Windows::Foundation::IStringable>().ToString();
                if (key.Compare(L"MOE.Main.Class")) {
                    std::wstring mainClassW = entry.Value().As<Modern::Windows::Foundation::IStringable>().ToString().Buffer();
                    // TODO: We have to add unicode argument support to ART, if it is not yet present
                    // and then remove this conversion below.
                    mainClass = std::string(mainClassW.begin(), mainClassW.end());
                }
            }
        } catch (Modern::Exception ex) {
            // Possibly failed to cast and that means that the key or value was not of the
            // type String or the Runtime is inaccessible.
        }
    }
    args.push_back(mainClass);

    if (mainClass.empty()) {
        assert(!"Missing MainClass! Tried from Application XAML and command line arguments.");
    }

    // Append java arguments
    while (jargi < jargc) {
        std::string opt(jargv[jargi++]);
        args.push_back(opt);
    }

    // Build up class preregister list
    WCHAR preregisters[MAX_PATH];
    wcsncpy_s(preregisters, MAX_PATH, execPath, MAX_PATH);
    PathCchAppend(preregisters, MAX_PATH, L"preregister.txt");
    std::wifstream preregisterFile(preregisters);
    std::wstring preregisterLine;
    std::vector<std::string> preregisterLines;
    while (std::getline(preregisterFile, preregisterLine)) {
        if (preregisterLine.empty()) {
            continue;
        }
        // TODO: We have to add unicode argument support to ART, if it is not yet present
        // and then remove this conversion below.
        preregisterLines.push_back(std::string(preregisterLine.begin(), preregisterLine.end()));
    }

    // Create c argument array for preregister list
    size_t prec = preregisterLines.size();
    const char** prev = (char const**)alloca(prec * sizeof(char*));
    for (size_t i = 0; i < prec; i++) {
        prev[i] = preregisterLines[i].c_str();
    }

    // Create c argument array
    size_t argc = args.size();
    const char** argv = (char const**)alloca((argc + 1) * sizeof(char*));
    for (size_t i = 0; i < argc; i++) {
        argv[i] = args[i].c_str();
    }
    argv[argc] = NULL;  // ART runtime requires a null terminator

    dalvikvm(argc, (char**)argv, prec, (char**)prev);
    return 0;
}
