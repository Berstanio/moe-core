/*
 * Copyright (c) 2014-2016, Intel Corporation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// ------------------------------ Init ------------------------------ //

buildscript {
    repositories {
        mavenCentral()
        maven { url { 'http://dl.bintray.com/youribonnaffe/maven' } }
    }

    dependencies {
        classpath 'org.gradle.api.plugins:gradle-format-plugin:1.1'
    }
}

apply plugin: 'java'
apply plugin: 'format'
apply plugin: 'checkstyle'

def JvmVersionMeets(version) {
	def currentJvm = org.gradle.internal.jvm.Jvm.current()
	return version <= Integer.parseInt(currentJvm.javaVersion.majorVersion)
}


// ------------------------------ Conscrypt Generation ------------------------------ //

task buildConscryptGenerator << {
	ByteArrayOutputStream ostream = new ByteArrayOutputStream();
    try {
        exec {
		 	executable = "xcodebuild"

		    args "-project", file("../moe.ios.core.native/android.external.conscrypt/android.external.conscrypt.xcodeproj").absolutePath
		    args "-target", "generate"
		    args "-configuration", "Release"

		    setErrorOutput(ostream)
            setStandardOutput(ostream)
	    }
    } catch(Exception ex) {
        throw new GradleScriptException("xcodebuild failed with: ${ostream}", ex);
    }
}

task generateConscryptFiles << {
	def log = new ByteArrayOutputStream();
	exec {
		commandLine "${inputs.files[0].absolutePath}"

		setErrorOutput(log)
		setStandardOutput(log)
	}
	mkdir(outputs.files[0].parentFile)
	PrintStream ps = new PrintStream(outputs.files[0])
	try {
		ps.println(log);
	} finally {
		ps.close();
	}
}

tasks.generateConscryptFiles.inputs.files file("../moe.ios.core.native/android.external.conscrypt/build/xcode/Release/generate")
tasks.generateConscryptFiles.outputs.files file('build/conscryptgen/NativeConstants.java')
tasks.generateConscryptFiles.dependsOn(tasks.buildConscryptGenerator)


// ------------------------------ Misc ------------------------------ //

def android_java_sources = [
	"${android_path}/external/bouncycastle/bcprov/src/main/java",
	"${android_path}/external/conscrypt/src/main/java",
	"${android_path}/external/conscrypt/src/platform/java",
    "${android_path}/external/javasqlite/src/main/java",
	"${android_path}/external/okhttp/android/main/java",
	"${android_path}/external/okhttp/okhttp/src/main/java",
	"${android_path}/external/okhttp/okhttp-android-support/src/main/java",
	"${android_path}/external/okhttp/okhttp-urlconnection/src/main/java",
	"${android_path}/external/okhttp/okio/okio/src/main/java",
	"${android_path}/libcore/dalvik/src/main/java",
	"${android_path}/libcore/dex/src/main/java",
	"${android_path}/libcore/libart/src/main/java",
	"${android_path}/libcore/luni/src/main/java",
	"${android_path}/libcore/ojluni/src/main/java",
	"${android_path}/libcore/ojluni/src_windows/main/java", // TODO: Should we include Java implementations for every platform?
	"${android_path}/libcore/xml/src/main/java",
	"${android_path}/external/icu/android_icu4j/src/main/java",
	tasks.generateConscryptFiles.outputs.files[0].parentFile.absolutePath,
]

sourceSets {
	styled {
        java {
            srcDirs = android_java_sources
            getFilter().exclude(new Spec<FileTreeElement>(){
			    public boolean isSatisfiedBy(    FileTreeElement element){
			      return !element.getFile().absolutePath.endsWith('okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java');
			    }
			});
        }
    }

    currencyRes {
	 	resources {
	    	srcDir "${android_path}/libcore/ojluni"
	    	include 'currency.data'
	  	}
	}


    core {
    	java {
    		srcDirs = android_java_sources
    		exclude {
				it.file.absolutePath.endsWith('okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java')
			}
		}
		resources {
			srcDirs = java.srcDirs + "${android_path}/libcore/ojluni/src/main/resources"
			srcDir currencyRes.resources
			exclude {
				it.file.absolutePath.endsWith('okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java')
			}
		}
    }

    ios {}

    natj {}

    junit {}
}

project.getTasks().getByName("compileCoreJava").sourceCompatibility = "1.8"
project.getTasks().getByName("compileCoreJava").targetCompatibility = "1.8"
project.getTasks().getByName("compileCoreJava").dependsOn(tasks.generateConscryptFiles)

configurations {
	jarjarJar {}
	natjSources {}
	testSources {}
}

dependencies {
    int repoIdx = 1;
    while (true) {
        String customRepo = System.getenv("MOE_PRIVATE_MAVEN_ADDR_$repoIdx")
        if (customRepo == null || customRepo.length() == 0) {
            break
        }
        repositories {
            maven {
                url(customRepo)
                String privateRepoUser = System.getenv("MOE_PRIVATE_MAVEN_USER_$repoIdx")
                if (privateRepoUser != null && privateRepoUser.length() > 0) {
                    credentials {
                        username = privateRepoUser
                        password = System.getenv("MOE_PRIVATE_MAVEN_PASS_$repoIdx")
                    }
                }
            }
        }
        ++repoIdx
    }
    repositories {
		if (project.hasProperty("moe.natj.repo")) {
    		maven {
        		url project.property("moe.natj.repo")
    		}
		} else {
			mavenLocal()
		}
        mavenCentral()
    }
    checkstyle 'com.puppycrawl.tools:checkstyle:6.1.1'
    jarjarJar 'org.pantsbuild:jarjar:1.6.3'

    compile 'org.moe:natj-api:1.0.+'

    natjSources 'org.moe:natj-api:1.0.+:sources'

    testCompile 'junit:junit:4.+'
    testSources 'junit:junit:4.+:sources'
	testSources 'org.hamcrest:hamcrest-core:1.+:sources'

	junitCompile 'junit:junit:4.+'
}

format {
    configurationFile = file('tools/android-formatting.xml')

    // Uncomment this if you want style format on Libcore
    files = /*sourceSets.main.java +*/ project.sourceSets.test.java
}

checkstyle {
    configFile = file('tools/checkstyle.xml')
    sourceSets = [sourceSets.test]
}

// Uncomment this if you want style check on Libcore
//tasks.compileJava.dependsOn("checkstyleStyledJavaSources")

// Don't run tests with the built-in junit
test { exclude '**' }

sourceCompatibility = "1.8"
targetCompatibility = "1.8"


// ------------------------------ NatJ Shpinx Generation ------------------------------ //

task unzipNatJSources(type: Copy) {
	from configurations.natjSources.collect { zipTree(it) }
	into file("build/unpacked/natj-sources")
}

task sphinxNatJSources(type: Exec, dependsOn:unzipNatJSources) {
	executable 'javasphinx-apidoc'

	environment = ['LC_ALL':'en_US.UTF-8', 'LANG':'en_US.UTF-8']

	def input = tasks.unzipNatJSources.outputs.files.getSingleFile()

	args input.absolutePath
	args '-c', file('build/javasphinxcache').absolutePath
	args '-u'
	args '-o', file('build/javasphinxoutput')
	args new File(input, 'org/moe/natj/org/').absolutePath
	args new File(input, 'org/moe/natj/general/ptr/impl/').absolutePath

	inputs.files input
	outputs.files file('build/javasphinxoutput')
}

task natjSphinxJar(type: Zip, dependsOn: sphinxNatJSources) {
	baseName 'moe'
	appendix 'ios'
	classifier 'natj-api-sphinx'

	tasks.sphinxNatJSources.outputs.each { from(it) }
	destinationDir file('build/libs/natj')
	extension 'jar'
    from (file('../eula/LICENSE.TXT'))
}


// ------------------------------ Core Jar Generation ------------------------------ //

def jarjarJars = [
	configurations.jarjarJar.files[0],
	project.file('tools/asm-5.1.jar'),
	project.file('tools/asm-commons-5.1.jar')
]

task jarjaredCoreBaseJar(dependsOn: compileCoreJava) {
    def prebuilts = [file("${android_path}/external/icu/icu4j/main/shared/data/icudata.jar"),
                     file("${android_path}/external/icu/icu4j/main/shared/data/icutzdata.jar")]

    inputs.files jarjarJars
	inputs.files sourceSets.core.output
    inputs.files prebuilts
	outputs.files "build/libs/core/jarjared.jar"

	doLast {
		ant {
			taskdef(
				name: 'jarjar',
				classname: 'org.pantsbuild.jarjar.JarJarTask',
				classpath: jarjarJars.join(':')
			)
			jarjar(jarfile: outputs.files[0]) {
				sourceSets.core.output.each {
					fileset(dir: it)
				}

                prebuilts.each {
                    zipfileset(src: it)
                }

				rule(pattern: 'com.squareup.**', result: 'com.android.@1')
				rule(pattern: 'org.conscrypt.**', result: 'com.android.org.conscrypt.@1')
				rule(pattern: 'org.bouncycastle.**', result: 'com.android.org.bouncycastle.@1')
				rule(pattern: 'okio.**', result: 'com.android.okio.@1')
				rule(pattern: 'com.ibm.icu.**', result: 'android.icu.@1')
			}
		}
	}
}

task coreJar(type: Jar, dependsOn: jarjaredCoreBaseJar) {
	baseName 'moe'
	appendix 'ios'
	classifier 'core'

	from zipTree(jarjaredCoreBaseJar.outputs.files[0])
	from { [rootProject.file('LICENSE'), rootProject.file('NOTICE')] }
	destinationDir file('build/libs/core')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}

task coreSourcesJar(type: Jar, dependsOn: compileCoreJava) {
	baseName 'moe'
	appendix 'ios'
	classifier 'core-sources'

	from rootProject.file('LICENSE'), rootProject.file('NOTICE')
	from sourceSets.core.allSource
	destinationDir file('build/libs/core-sources')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}


// ------------------------------ Core Javadoc Jar Generation ------------------------------ //

task coreJavadoc(type: Javadoc) {
	source sourceSets.core.allJava
	destinationDir = file('build/docs/coreJavadoc')
	include "**/*.java"
	if (JvmVersionMeets(8)) {
		options.addStringOption('Xdoclint:none', '-quiet')
	}
}

task coreJavadocJar(type: Jar, dependsOn: coreJavadoc) {
	baseName 'moe'
	appendix 'ios'
	classifier 'core-javadoc'

	from coreJavadoc.destinationDir
	from { [rootProject.file('LICENSE'), rootProject.file('NOTICE')] }
	destinationDir file('build/libs/core')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}


// ------------------------------ iOS Jar Generation ------------------------------ //

task iosJar(type: Jar, dependsOn: compileJava) {
	baseName 'moe'
	appendix 'ios'
	classifier 'ios'

	from configurations.compile.collect {
		it.isDirectory() ? it : zipTree(it)
	} + [rootProject.file('LICENSE'), rootProject.file('NOTICE')]
	from sourceSets.main.output
	destinationDir file('build/libs/ios')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}

task iosSourcesJar(type: Jar, dependsOn: iosJar) {
	baseName 'moe'
	appendix 'ios'
	classifier 'ios-sources'

	from rootProject.file('LICENSE'), rootProject.file('NOTICE')
	from sourceSets.main.allSource
	destinationDir file('build/libs/ios-sources')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}


// ------------------------------ iOS Javadoc Jar Generation ------------------------------ //

task iosJavadoc(type: Javadoc) {
	source sourceSets.main.allJava
	source configurations.natjSources.collect { zipTree(it) }
	destinationDir = file('build/docs/iosJavadoc')
	include "**/*.java"
	if (JvmVersionMeets(8)) {
		options.addStringOption('Xdoclint:none', '-quiet')
	}
}

task iosJavadocJar(type: Jar, dependsOn: iosJavadoc) {
	baseName 'moe'
	appendix 'ios'
	classifier 'ios-javadoc'

	from iosJavadoc.destinationDir
	from { [rootProject.file('LICENSE'), rootProject.file('NOTICE')] }
	destinationDir file('build/libs/ios')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}


// ------------------------------ jUnit Jar Generation ------------------------------ //

task junitJar(type: Jar, dependsOn: compileTestJava) {
	baseName 'moe'
	appendix 'ios'
	classifier 'junit'
	from configurations.junitCompile.collect {
		it.isDirectory() ? it : zipTree(it)
	} + [rootProject.file('LICENSE'), rootProject.file('NOTICE')]
	from sourceSets.test.output
	destinationDir file('build/libs/junit')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}

task junitSourcesJar(type: Jar, dependsOn: junitJar) {
	baseName 'moe'
	appendix 'ios'
	classifier 'junit-sources'

	from rootProject.file('LICENSE'), rootProject.file('NOTICE')
	from sourceSets.test.allSource
	destinationDir file('build/libs/junit-sources')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}


// ------------------------------ jUnit Javadoc Jar Generation ------------------------------ //

task junitJavadoc(type: Javadoc, dependsOn: iosJar) {
	source sourceSets.test.allJava
	source configurations.testSources.collect { zipTree(it) }
	classpath = iosJar.outputs.files
	destinationDir = file('build/docs/junitJavadoc')
	include "**/*.java"
	if (JvmVersionMeets(8)) {
		options.addStringOption('Xdoclint:none', '-quiet')
	}
}

task junitJavadocJar(type: Jar, dependsOn: junitJavadoc) {
	baseName 'moe'
	appendix 'ios'
	classifier 'junit-javadoc'

	from junitJavadoc.destinationDir
	from { [rootProject.file('LICENSE'), rootProject.file('NOTICE')] }
	destinationDir file('build/libs/junit')
    from (file('../eula/LICENSE.TXT')) { into 'META-INF' }
}
